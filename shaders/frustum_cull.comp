// Compute shader for GPU-driven frustum culling of circle instances
#version 450

// Workgroup size - process 64 instances per workgroup for good occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Structure definition (matches InstanceLayoutCPU from C++)
struct InstanceData {
    vec2 center;        // float center[2]
    float radius;       // float radius
    float lodTier;      // float lodTier
    vec4 color;         // float color[4]
    float imageLayer;   // float imageLayer
    vec3 pad;           // float pad2[3] - padding for alignment
};

// Input: raw instance data from simulation (all alive circles)
layout(set = 0, binding = 0, std430) restrict readonly buffer InputInstanceData {
    InstanceData inputInstances[];
};

// Output: visibility buffer containing culled instance indices
layout(set = 0, binding = 1, std430) restrict writeonly buffer VisibilityBuffer {
    uint visibleInstanceIndices[];
};

// Output: atomic counter for number of visible instances
layout(set = 0, binding = 2, std430) restrict buffer VisibilityCounter {
    uint visibleCount;
};

// Push constants: frustum parameters and viewport info
layout(push_constant) uniform FrustumCullPushConstants {
    vec2 viewport;          // viewport dimensions (width, height)
    vec2 cameraOffset;      // camera center offset (for future camera system)
    uint maxInstances;      // maximum number of input instances
    uint hizEnabled;        // 1 when Hi-Z occlusion should run
    uint hizMipCount;       // number of mips available in the Hi-Z pyramid
    uint pad0;              // padding
} pc;

layout(set = 0, binding = 3) uniform sampler2D hizTexture;

const float CIRCLE_DEPTH_RADIUS_SCALE = 600.0;
const float CIRCLE_DEPTH_RANGE = 0.9;
const float HIZ_EPSILON_MIN = 0.0006;
const float HIZ_EPSILON_MAX = 0.0035;
const float HIZ_EPSILON_SMALL_RADIUS = 2.0;
const float HIZ_EPSILON_LARGE_RADIUS = 48.0;

float computeCircleDepth(float radius) {
    float t = clamp(radius / CIRCLE_DEPTH_RADIUS_SCALE, 0.0, 1.0);
    return 1.0 - t * CIRCLE_DEPTH_RANGE;
}

float computeHiZEpsilon(float radiusPixels) {
    float blend = clamp((radiusPixels - HIZ_EPSILON_SMALL_RADIUS) /
                        max(HIZ_EPSILON_LARGE_RADIUS - HIZ_EPSILON_SMALL_RADIUS, 1.0),
                        0.0, 1.0);
    return mix(HIZ_EPSILON_MAX, HIZ_EPSILON_MIN, blend);
}

bool isCircleOccluded(vec2 screenUV, float radiusPixels, float circleDepth) {
    vec2 radiusUV = vec2(radiusPixels) / pc.viewport;
    vec2 minUV = screenUV - radiusUV;
    vec2 maxUV = screenUV + radiusUV;

    vec2 clampedMin = clamp(minUV, vec2(0.0), vec2(1.0));
    vec2 clampedMax = clamp(maxUV, vec2(0.0), vec2(1.0));

    float diameter = max(radiusPixels * 2.0, 1.0);
    float maxLevel = float(max(int(pc.hizMipCount) - 1, 0));
    float level = clamp(floor(log2(diameter)), 0.0, maxLevel);

    float minDepth = textureLod(hizTexture, clamp((clampedMin + clampedMax) * 0.5, vec2(0.0), vec2(1.0)), level).r;
    minDepth = min(minDepth, textureLod(hizTexture, vec2(clampedMin.x, clampedMin.y), level).r);
    minDepth = min(minDepth, textureLod(hizTexture, vec2(clampedMax.x, clampedMin.y), level).r);
    minDepth = min(minDepth, textureLod(hizTexture, vec2(clampedMin.x, clampedMax.y), level).r);
    minDepth = min(minDepth, textureLod(hizTexture, vec2(clampedMax.x, clampedMax.y), level).r);

    float epsilon = computeHiZEpsilon(radiusPixels);
    return minDepth <= (circleDepth - epsilon);
}

// Simple frustum culling function for 2D circles
bool isCircleVisible(vec2 center, float radius, vec2 viewport, vec2 cameraOffset) {
    // Transform circle center relative to camera
    vec2 relativeCenter = center - cameraOffset;
    
    // Convert to NDC space for culling
    vec2 ndc = (relativeCenter / viewport) * 2.0 - 1.0;
    
    // Calculate circle bounds in NDC space
    vec2 radiusNDC = (vec2(radius) / viewport) * 2.0;
    float maxRadiusNDC = max(radiusNDC.x, radiusNDC.y);
    
    // Frustum culling: check if circle overlaps with [-1, 1] NDC cube
    // Circle is visible if any part overlaps the visible area
    bool xVisible = (ndc.x + maxRadiusNDC >= -1.0) && (ndc.x - maxRadiusNDC <= 1.0);
    bool yVisible = (ndc.y + maxRadiusNDC >= -1.0) && (ndc.y - maxRadiusNDC <= 1.0);
    
    return xVisible && yVisible;
}

void main() {
    uint instanceIndex = gl_GlobalInvocationID.x;
    
    // Bounds check
    if (instanceIndex >= pc.maxInstances) {
        return;
    }
    
    // Load instance data
    InstanceData instance = inputInstances[instanceIndex];
    
    // Perform frustum culling
    bool visible = isCircleVisible(
        instance.center,
        instance.radius,
        pc.viewport,
        pc.cameraOffset
    );

    if (visible && pc.hizEnabled == 1u) {
        vec2 screenUV = (instance.center - pc.cameraOffset) / pc.viewport;
        float circleDepth = computeCircleDepth(instance.radius);
        if (isCircleOccluded(screenUV, instance.radius, circleDepth)) {
            visible = false;
        }
    }

    // If visible, add to output buffer
    if (visible) {
        uint outputIndex = atomicAdd(visibleCount, 1);
        
        // Ensure we don't overflow the visibility buffer
        if (outputIndex < visibleInstanceIndices.length()) {
            visibleInstanceIndices[outputIndex] = instanceIndex;
        }
    }
}
