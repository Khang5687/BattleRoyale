// Compute shader for GPU-driven frustum culling of circle instances
#version 450

// Workgroup size - process 64 instances per workgroup for good occupancy
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Structure definition (matches InstanceLayoutCPU from C++)
struct InstanceData {
    vec2 center;        // float center[2]
    float radius;       // float radius
    float lodTier;      // float lodTier
    vec4 color;         // float color[4]
    float imageLayer;   // float imageLayer
    vec3 pad;           // float pad2[3] - padding for alignment
};

// Input: raw instance data from simulation (all alive circles)
layout(set = 0, binding = 0, std430) restrict readonly buffer InputInstanceData {
    InstanceData inputInstances[];
};

// Output: visibility buffer containing culled instance indices
layout(set = 0, binding = 1, std430) restrict writeonly buffer VisibilityBuffer {
    uint visibleInstanceIndices[];
};

// Output: atomic counter for number of visible instances
layout(set = 0, binding = 2, std430) restrict buffer VisibilityCounter {
    uint visibleCount;
};

// Push constants: frustum parameters and viewport info
layout(push_constant) uniform FrustumCullPushConstants {
    vec2 viewport;          // viewport dimensions (width, height)
    vec2 cameraOffset;      // camera center offset (for future camera system)
    uint maxInstances;      // maximum number of input instances
    uint pad1;              // padding for alignment
} pc;

// Simple frustum culling function for 2D circles
bool isCircleVisible(vec2 center, float radius, vec2 viewport, vec2 cameraOffset) {
    // Transform circle center relative to camera
    vec2 relativeCenter = center - cameraOffset;
    
    // Convert to NDC space for culling
    vec2 ndc = (relativeCenter / viewport) * 2.0 - 1.0;
    
    // Calculate circle bounds in NDC space
    vec2 radiusNDC = (vec2(radius) / viewport) * 2.0;
    float maxRadiusNDC = max(radiusNDC.x, radiusNDC.y);
    
    // Frustum culling: check if circle overlaps with [-1, 1] NDC cube
    // Circle is visible if any part overlaps the visible area
    bool xVisible = (ndc.x + maxRadiusNDC >= -1.0) && (ndc.x - maxRadiusNDC <= 1.0);
    bool yVisible = (ndc.y + maxRadiusNDC >= -1.0) && (ndc.y - maxRadiusNDC <= 1.0);
    
    return xVisible && yVisible;
}

void main() {
    uint instanceIndex = gl_GlobalInvocationID.x;
    
    // Bounds check
    if (instanceIndex >= pc.maxInstances) {
        return;
    }
    
    // Load instance data
    InstanceData instance = inputInstances[instanceIndex];
    
    // Perform frustum culling
    bool visible = isCircleVisible(
        instance.center, 
        instance.radius, 
        pc.viewport, 
        pc.cameraOffset
    );
    
    // If visible, add to output buffer
    if (visible) {
        uint outputIndex = atomicAdd(visibleCount, 1);
        
        // Ensure we don't overflow the visibility buffer
        if (outputIndex < visibleInstanceIndices.length()) {
            visibleInstanceIndices[outputIndex] = instanceIndex;
        }
    }
}
