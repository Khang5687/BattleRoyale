#version 450

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

const uint REQUEST_STATE_IDLE = 0u;
const uint REQUEST_STATE_READY = 1u;
const uint REQUEST_STATE_COMPLETE = 3u;

struct StreamRequest {
    uint state;
    uint layer;
    uint width;
    uint height;
    uint pixelOffset;
    uint imageId;
    uint reserved0;
    uint reserved1;
};

layout(set = 0, binding = 0, std430) buffer RequestBuffer {
    StreamRequest requests[];
};

layout(set = 0, binding = 1, std430) readonly buffer PixelBuffer {
    uint pixelData[];
};

layout(set = 0, binding = 2, rgba8) uniform writeonly image2DArray atlas;

vec4 unpackColor(uint packed) {
    return vec4(
        float(packed & 0xFFu),
        float((packed >> 8) & 0xFFu),
        float((packed >> 16) & 0xFFu),
        float((packed >> 24) & 0xFFu)
    ) / 255.0;
}

void main() {
    uint slot = gl_WorkGroupID.x;
    StreamRequest req = requests[slot];

    if (req.state != REQUEST_STATE_READY) {
        return;
    }

    uint width = req.width;
    uint height = req.height;
    if (width == 0u || height == 0u) {
        return;
    }

    for (uint y = gl_LocalInvocationID.y; y < height; y += gl_WorkGroupSize.y) {
        for (uint x = gl_LocalInvocationID.x; x < width; x += gl_WorkGroupSize.x) {
            uint index = req.pixelOffset + y * width + x;
            uint packed = pixelData[index];
            imageStore(atlas, ivec3(int(x), int(y), int(req.layer)), unpackColor(packed));
        }
    }

    memoryBarrierImage();
    barrier();

    if (gl_LocalInvocationIndex == 0u) {
        memoryBarrierBuffer();
        requests[slot].state = REQUEST_STATE_COMPLETE;
    }
}
