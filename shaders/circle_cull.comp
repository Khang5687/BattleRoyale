#version 450

// P2: Instance compaction compute shader
// Reads visibility results from P1 and generates compacted instances + draw commands

// Workgroup size - configurable via specialization constants for vendor optimization
// NVIDIA: 32 threads (warp size), AMD: 64 threads (wavefront size)
layout(constant_id = 0) const uint WORKGROUP_SIZE_X = 64;
layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

// NVIDIA FIX: Dummy shared memory to workaround NVIDIA barrier() bug
// Without any shared memory access, barrier() fails to synchronize on NVIDIA GPUs
// Reference: https://forums.developer.nvidia.com/t/barrier-failing-if-there-isnt-any-shared-memory-used/252614
shared uint nvidia_barrier_workaround;

// Push constants
layout(push_constant) uniform CompactionConstants {
    uint maxInstances;
    uint maxHealthBars;
    uint enableHealthBars;
    uint pad1;
} pc;

// Instance layout matching CPU InstanceLayoutCPU
struct InstanceData {
    vec2 center;
    float radius;
    float lodTier;
    vec4 color;
    uint textureIndex;
    vec3 pad;
};

// Health bar instance layout matching CPU HealthBarInstance
struct HealthBarData {
    vec2 center;
    vec2 size;
    float fillRatio;
    float tier;
};

// Indirect draw command layout matching VkDrawIndirectCommand
struct DrawCommand {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
};

// Input buffers from P1 frustum culling
layout(std430, binding = 0) readonly buffer InputInstanceBuffer {
    InstanceData inputInstances[];
};

layout(std430, binding = 1) readonly buffer VisibilityIndexBuffer {
    uint visibilityIndices[];
};

// NVIDIA FIX: coherent qualifier ensures atomic visibility across workgroups
layout(std430, binding = 2) coherent readonly buffer VisibilityCounterBuffer {
    uint visibleCount;
};

// Input health bar data (generated on CPU)
layout(std430, binding = 3) readonly buffer InputHealthBarBuffer {
    HealthBarData inputHealthBars[];
};

// Output buffers for P2 indirect drawing
layout(std430, binding = 4) writeonly buffer CircleDrawCommandBuffer {
    DrawCommand circleDrawCommand;
};

layout(std430, binding = 5) writeonly buffer HealthBarDrawCommandBuffer {
    DrawCommand healthBarDrawCommand;
};

layout(std430, binding = 6) writeonly buffer CompactedCircleBuffer {
    InstanceData compactedCircles[];
};

layout(std430, binding = 7) writeonly buffer CompactedHealthBarBuffer {
    HealthBarData compactedHealthBars[];
};

layout(std430, binding = 8) writeonly buffer HealthBarVisibilityBuffer {
    uint healthBarIndices[];
};

layout(std430, binding = 9) coherent buffer HealthBarCounterBuffer {
    uint healthBarCount;
};

void main() {
    uint index = gl_GlobalInvocationID.x;
    
    // NVIDIA barrier workaround: Touch shared memory to enable proper synchronization
    if (gl_LocalInvocationID.x == 0) {
        nvidia_barrier_workaround = 0;
    }
    
    // Initialize draw commands on first thread
    if (index == 0) {
        // Circle draw command
        circleDrawCommand.vertexCount = 6;          // Quad vertices
        circleDrawCommand.instanceCount = visibleCount;
        circleDrawCommand.firstVertex = 0;
        circleDrawCommand.firstInstance = 0;
        memoryBarrierBuffer(); // CRITICAL: Ensure draw command visible to graphics pipeline

        // Health bar draw command (will be updated later)
        healthBarDrawCommand.vertexCount = 6;
        healthBarDrawCommand.instanceCount = 0;    // Will be set after health bar processing
        healthBarDrawCommand.firstVertex = 0;
        healthBarDrawCommand.firstInstance = 0;
        memoryBarrierBuffer(); // Ensure health bar draw command visible

        // Reset health bar counter
        healthBarCount = 0;
    }
    
    barrier();
    
    // Compact visible circle instances
    if (index < visibleCount) {
        uint visibleInstanceIndex = visibilityIndices[index];
        if (visibleInstanceIndex < pc.maxInstances) {
            compactedCircles[index] = inputInstances[visibleInstanceIndex];
        }
    }
    
    // Process health bars if enabled
    if (pc.enableHealthBars != 0) {
        barrier();
        memoryBarrierBuffer(); // Ensure all previous writes are visible
        
        // For each visible circle, check if it has a corresponding health bar
        if (index < visibleCount) {
            uint circleIndex = visibilityIndices[index];
            
            // Simple approach: assume health bar index matches circle index
            if (circleIndex < pc.maxHealthBars) {
                HealthBarData healthBar = inputHealthBars[circleIndex];
                
                // Check if this health bar should be visible
                if (healthBar.fillRatio > 0.0) {
                    uint healthBarOutputIndex = atomicAdd(healthBarCount, 1);
                    memoryBarrierBuffer(); // CRITICAL: Ensure atomic result is visible to all threads
                    
                    if (healthBarOutputIndex < pc.maxHealthBars) {
                        compactedHealthBars[healthBarOutputIndex] = healthBar;
                        healthBarIndices[healthBarOutputIndex] = circleIndex;
                    }
                }
            }
        }
        
        barrier();
        memoryBarrierBuffer(); // Ensure all buffer writes complete before final update
        
        // Update health bar draw command with final count
        if (index == 0) {
            healthBarDrawCommand.instanceCount = healthBarCount;
            memoryBarrierBuffer(); // Ensure updated draw command visible to graphics pipeline
        }
    }
}
