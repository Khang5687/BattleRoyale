#include "simd_verification.hpp"
#include <algorithm>
#include <random>
#include <cstring>

namespace spatial {

// Static member initialization
bool CacheProfiler::profilingActive = false;
CacheProfiler::CacheMetrics CacheProfiler::currentMetrics = {};

SIMDVerification::MemoryLayoutMetrics SIMDVerification::verifyEntityDataLayout(const std::vector<EntityData>& entities) {
    MemoryLayoutMetrics metrics = {};\n\n    if (entities.empty()) {\n        return metrics;\n    }\n\n    // Check alignment\n    const void* dataPtr = entities.data();\n    metrics.isAligned16 = isMemoryAligned(dataPtr, 16);\n    metrics.isAligned32 = isMemoryAligned(dataPtr, 32);\n\n    // Calculate cache line utilization\n    metrics.cacheLineUtilization = calculateCacheLineUtilization(entities);\n\n    // Benchmark vectorized vs scalar operations\n    vec2 queryPoint = {400.0f, 300.0f};\n    float radius = 50.0f;\n    benchmarkDistanceCalculations(entities, queryPoint, radius, metrics);\n\n    // Calculate vectorization efficiency\n    if (metrics.scalarTime.count() > 0) {\n        metrics.speedupRatio = static_cast<double>(metrics.scalarTime.count()) / metrics.simdTime.count();\n        metrics.vectorizationEfficiency = (metrics.speedupRatio - 1.0) / 3.0; // Theoretical 4x speedup\n    }\n\n    return metrics;\n}\n\nvoid SIMDVerification::benchmarkDistanceCalculations(const std::vector<EntityData>& entities,\n                                                     const vec2& queryPoint, float radius,\n                                                     MemoryLayoutMetrics& metrics) {\n    const size_t testIterations = 1000;\n    const size_t entityCount = std::min(entities.size(), size_t(1000));\n\n    // Scalar benchmark\n    auto start = std::chrono::high_resolution_clock::now();\n    for (size_t iter = 0; iter < testIterations; ++iter) {\n        volatile int results = 0;\n        for (size_t i = 0; i < entityCount; ++i) {\n            float dx = entities[i].posX - queryPoint.x;\n            float dy = entities[i].posY - queryPoint.y;\n            float distSq = dx * dx + dy * dy;\n            float radiusSum = entities[i].radius + radius;\n            if (distSq <= radiusSum * radiusSum) {\n                results++;\n            }\n        }\n    }\n    auto end = std::chrono::high_resolution_clock::now();\n    metrics.scalarTime = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);\n\n    // SIMD benchmark\n    start = std::chrono::high_resolution_clock::now();\n    for (size_t iter = 0; iter < testIterations; ++iter) {\n        volatile int results = 0;\n        size_t i = 0;\n        const size_t simdWidth = 4;\n\n        __m128 queryX = _mm_set1_ps(queryPoint.x);\n        __m128 queryY = _mm_set1_ps(queryPoint.y);\n        __m128 queryRadius = _mm_set1_ps(radius);\n\n        for (; i + simdWidth <= entityCount; i += simdWidth) {\n            // Load 4 entities at once\n            __m128 posX = _mm_set_ps(\n                entities[i + 3].posX, entities[i + 2].posX,\n                entities[i + 1].posX, entities[i].posX\n            );\n            __m128 posY = _mm_set_ps(\n                entities[i + 3].posY, entities[i + 2].posY,\n                entities[i + 1].posY, entities[i].posY\n            );\n            __m128 entityRadius = _mm_set_ps(\n                entities[i + 3].radius, entities[i + 2].radius,\n                entities[i + 1].radius, entities[i].radius\n            );\n\n            // Calculate distances\n            __m128 dx = _mm_sub_ps(posX, queryX);\n            __m128 dy = _mm_sub_ps(posY, queryY);\n            __m128 distSq = _mm_add_ps(_mm_mul_ps(dx, dx), _mm_mul_ps(dy, dy));\n\n            // Calculate radius sum\n            __m128 radiusSum = _mm_add_ps(entityRadius, queryRadius);\n            __m128 radiusSumSq = _mm_mul_ps(radiusSum, radiusSum);\n\n            // Compare\n            __m128 mask = _mm_cmple_ps(distSq, radiusSumSq);\n\n            // Count results\n            alignas(16) float maskArray[4];\n            _mm_store_ps(maskArray, mask);\n            for (int j = 0; j < 4; ++j) {\n                if (maskArray[j] != 0.0f) results++;\n            }\n        }\n\n        // Handle remaining entities\n        for (; i < entityCount; ++i) {\n            float dx = entities[i].posX - queryPoint.x;\n            float dy = entities[i].posY - queryPoint.y;\n            float distSq = dx * dx + dy * dy;\n            float radiusSum = entities[i].radius + radius;\n            if (distSq <= radiusSum * radiusSum) {\n                results++;\n            }\n        }\n    }\n    end = std::chrono::high_resolution_clock::now();\n    metrics.simdTime = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);\n}\n\nvoid SIMDVerification::verifyCacheEfficiency(const std::vector<EntityData>& entities,\n                                           MemoryLayoutMetrics& metrics) {\n    if (entities.empty()) return;\n\n    // Test sequential vs random access patterns\n    const size_t testSize = std::min(entities.size(), size_t(10000));\n    std::vector<size_t> indices(testSize);\n    std::iota(indices.begin(), indices.end(), 0);\n\n    // Random access pattern test\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::shuffle(indices.begin(), indices.end(), gen);\n\n    auto start = std::chrono::high_resolution_clock::now();\n    volatile float sum = 0.0f;\n    for (size_t idx : indices) {\n        sum += entities[idx].posX + entities[idx].posY;\n    }\n    auto end = std::chrono::high_resolution_clock::now();\n    auto randomTime = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);\n\n    // Sequential access pattern test\n    start = std::chrono::high_resolution_clock::now();\n    sum = 0.0f;\n    for (size_t i = 0; i < testSize; ++i) {\n        sum += entities[i].posX + entities[i].posY;\n    }\n    end = std::chrono::high_resolution_clock::now();\n    auto sequentialTime = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);\n\n    // Cache efficiency ratio (lower is better)\n    double efficiency = static_cast<double>(sequentialTime.count()) / randomTime.count();\n    metrics.vectorizationEfficiency = std::max(metrics.vectorizationEfficiency, efficiency);\n}\n\nvoid SIMDVerification::batchCollisionDetection(const EntityData* entities, size_t count,\n                                              std::vector<std::pair<uint32_t, uint32_t>>& collisions) {\n    collisions.clear();\n    const size_t simdWidth = 4;\n\n    for (size_t i = 0; i < count; i += simdWidth) {\n        size_t remainingCount = std::min(simdWidth, count - i);\n\n        // Load entity data for this batch\n        alignas(16) float posX[4], posY[4], radius[4];\n        alignas(16) uint32_t ids[4];\n\n        for (size_t j = 0; j < remainingCount; ++j) {\n            posX[j] = entities[i + j].posX;\n            posY[j] = entities[i + j].posY;\n            radius[j] = entities[i + j].radius;\n            ids[j] = entities[i + j].entityId;\n        }\n\n        __m128 batchPosX = _mm_load_ps(posX);\n        __m128 batchPosY = _mm_load_ps(posY);\n        __m128 batchRadius = _mm_load_ps(radius);\n\n        // Test against all other entities\n        for (size_t j = i + remainingCount; j < count; ++j) {\n            __m128 otherPosX = _mm_set1_ps(entities[j].posX);\n            __m128 otherPosY = _mm_set1_ps(entities[j].posY);\n            __m128 otherRadius = _mm_set1_ps(entities[j].radius);\n\n            __m128 dx = _mm_sub_ps(batchPosX, otherPosX);\n            __m128 dy = _mm_sub_ps(batchPosY, otherPosY);\n            __m128 distSq = _mm_add_ps(_mm_mul_ps(dx, dx), _mm_mul_ps(dy, dy));\n\n            __m128 radiusSum = _mm_add_ps(batchRadius, otherRadius);\n            __m128 radiusSumSq = _mm_mul_ps(radiusSum, radiusSum);\n\n            __m128 mask = _mm_cmple_ps(distSq, radiusSumSq);\n\n            alignas(16) float maskArray[4];\n            _mm_store_ps(maskArray, mask);\n\n            for (size_t k = 0; k < remainingCount; ++k) {\n                if (maskArray[k] != 0.0f) {\n                    collisions.emplace_back(ids[k], entities[j].entityId);\n                }\n            }\n        }\n    }\n}\n\nvoid SIMDVerification::prefetchEntityData(const EntityData* entities, size_t startIndex, size_t count) {\n    const size_t cacheLineSize = 64; // bytes\n    const size_t entitiesPerCacheLine = cacheLineSize / sizeof(EntityData);\n\n    for (size_t i = startIndex; i < startIndex + count; i += entitiesPerCacheLine) {\n        _mm_prefetch(reinterpret_cast<const char*>(&entities[i]), _MM_HINT_T0);\n    }\n}\n\n__m128 SIMDVerification::loadEntityPositions(const EntityData& entity) {\n    return _mm_set_ps(0.0f, 0.0f, entity.posY, entity.posX);\n}\n\nbool SIMDVerification::isMemoryAligned(const void* ptr, size_t alignment) {\n    return reinterpret_cast<uintptr_t>(ptr) % alignment == 0;\n}\n\nsize_t SIMDVerification::calculateCacheLineUtilization(const std::vector<EntityData>& entities) {\n    if (entities.empty()) return 0;\n\n    const size_t cacheLineSize = 64; // bytes\n    const size_t entitySize = sizeof(EntityData);\n    const size_t entitiesPerCacheLine = cacheLineSize / entitySize;\n\n    // Calculate how much of each cache line is utilized\n    size_t totalCacheLines = (entities.size() + entitiesPerCacheLine - 1) / entitiesPerCacheLine;\n    size_t utilizationPercentage = (entities.size() % entitiesPerCacheLine) > 0 ?\n        ((entities.size() % entitiesPerCacheLine) * 100) / entitiesPerCacheLine : 100;\n\n    return utilizationPercentage;\n}\n\n// CacheProfiler implementation (simplified for now)\nvoid CacheProfiler::startProfiling() {\n    profilingActive = true;\n    currentMetrics = {}; // Reset metrics\n}\n\nvoid CacheProfiler::stopProfiling() {\n    profilingActive = false;\n}\n\nCacheProfiler::CacheMetrics CacheProfiler::getMetrics() {\n    if (profilingActive) {\n        // In a real implementation, this would use hardware performance counters\n        // For now, return placeholder values\n        currentMetrics.l1Hits = 1000000;\n        currentMetrics.l1Misses = 50000;\n        currentMetrics.l2Hits = 45000;\n        currentMetrics.l2Misses = 5000;\n        currentMetrics.l3Hits = 4500;\n        currentMetrics.l3Misses = 500;\n\n        currentMetrics.hitRateL1 = static_cast<double>(currentMetrics.l1Hits) / \n            (currentMetrics.l1Hits + currentMetrics.l1Misses);\n        currentMetrics.hitRateL2 = static_cast<double>(currentMetrics.l2Hits) / \n            (currentMetrics.l2Hits + currentMetrics.l2Misses);\n        currentMetrics.hitRateL3 = static_cast<double>(currentMetrics.l3Hits) / \n            (currentMetrics.l3Hits + currentMetrics.l3Misses);\n    }\n    return currentMetrics;\n}\n\n} // namespace spatial